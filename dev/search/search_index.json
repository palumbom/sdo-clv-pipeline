{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SDO Center-to-Limb Variability (CLV) Pipeline","text":"<p>This package processes SDO data to recover trends in the center-to-limbv ariability of the solar radial velocity. v0.x.y is described in Palumbo et al. (2024b). The results of this paper can be reproduced using the showyourwork workflow from this repo.</p>"},{"location":"#installation","title":"Installation","text":"<p>The <code>sdo-clv-pipeline</code> package can be trivially installed using the <code>uv</code> tool:</p> <pre><code>git clone https://github.com/palumbom/sdo-clv-pipeline.git\ncd sdo-clv-pipeline\nuv sync\n</code></pre> <p>Then in Python, simply:</p> <pre><code>import sdo_clv_pipeline\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use this code in your research, please cite the relevant software release and paper.</p>"},{"location":"#author-contact","title":"Author &amp; Contact","text":"<p>This repo is maintained by Michael Palumbo. You may may contact him via his email - mpalumbo@flatironinstitute.org</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2021 Michael L. Palumbo (palumbo.astro@gmail.com) and contributors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"public-api/","title":"Public API","text":""},{"location":"public-api/#sdo_clv_pipelinesdo_image","title":"sdo_clv_pipeline.sdo_image","text":"<p>SDO image handling and region masking utilities.</p> <code>SDOImage</code> <p>             Bases: <code>object</code></p> <p>Load an SDO image and provide geometry, corrections, and metadata.</p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>str</code>)           \u2013            <p>Path to the FITS file to load.</p> </li> <li> <code>dtype</code>               (<code>numpy dtype</code>, default:                   <code>float32</code> )           \u2013            <p>Data type for the image array.</p> </li> </ul> <code>calc_limb_darkening(mu_lim=0.1, num_mu=25, n_sigma=2.0)</code> <p>Estimate limb darkening and flatten continuum/filtergram intensity.</p> <p>Parameters:</p> <ul> <li> <code>mu_lim</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>Minimum mu used in the fit.</p> </li> <li> <code>num_mu</code>               (<code>int</code>, default:                   <code>25</code> )           \u2013            <p>Number of mu bins between mu_lim and 1.</p> </li> <li> <code>n_sigma</code>               (<code>float</code>, default:                   <code>2.0</code> )           \u2013            <p>Sigma clipping threshold within each bin.</p> </li> </ul> <code>correct_dopplergram(fit_cbs=False)</code> <p>Compute velocity corrections and derived components for dopplergrams.</p> <p>Parameters:</p> <ul> <li> <code>fit_cbs</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, fit convective blueshift components in the bulk velocity model.</p> </li> </ul> <code>correct_magnetogram()</code> <p>Apply mu correction to magnetogram values.</p> <code>rescale_to_hmi(hmi_image)</code> <p>Resample a filtergram onto an HMI image grid and inherit geometry.</p> <p>Parameters:</p> <ul> <li> <code>hmi_image</code>               (<code>SDOImage</code>)           \u2013            <p>Target HMI image providing the output WCS and geometry.</p> </li> </ul> <code>SunMask</code> <p>             Bases: <code>object</code></p> <p>Classify solar regions using continuum, magnetogram, doppler, and AIA data.</p> <p>Parameters:</p> <ul> <li> <code>con</code>               (<code>SDOImage</code>)           \u2013            <p>Continuum, magnetogram, dopplergram, and filtergram images. These are used to derive masks for umbrae, penumbrae, quiet sun, network, plage, and moat flow regions.</p> </li> <li> <code>mag</code>               (<code>SDOImage</code>)           \u2013            <p>Continuum, magnetogram, dopplergram, and filtergram images. These are used to derive masks for umbrae, penumbrae, quiet sun, network, plage, and moat flow regions.</p> </li> <li> <code>dop</code>               (<code>SDOImage</code>)           \u2013            <p>Continuum, magnetogram, dopplergram, and filtergram images. These are used to derive masks for umbrae, penumbrae, quiet sun, network, plage, and moat flow regions.</p> </li> <li> <code>aia</code>               (<code>SDOImage</code>)           \u2013            <p>Continuum, magnetogram, dopplergram, and filtergram images. These are used to derive masks for umbrae, penumbrae, quiet sun, network, plage, and moat flow regions.</p> </li> </ul> <code>is_blue_penumbra()</code> <p>Return mask for blue-shifted penumbra regions.</p> <code>is_left_moat()</code> <p>Return mask for left-hand moat flow regions.</p> <code>is_moat_flow()</code> <p>Return mask for moat flow regions.</p> <code>is_network()</code> <p>Return mask for network regions.</p> <code>is_penumbra()</code> <p>Return mask for penumbra regions.</p> <code>is_plage()</code> <p>Return mask for plage regions.</p> <code>is_quiet_sun()</code> <p>Return mask for quiet sun regions.</p> <code>is_red_penumbra()</code> <p>Return mask for red-shifted penumbra regions.</p> <code>is_right_moat()</code> <p>Return mask for right-hand moat flow regions.</p> <code>is_umbra()</code> <p>Return mask for umbra regions.</p> <code>is_unclassified()</code> <p>Return mask for pixels with no valid region classification.</p>"},{"location":"public-api/#sdo_clv_pipelinesdo_process","title":"sdo_clv_pipeline.sdo_process","text":"<p>SDO processing pipeline entry points for per-epoch reductions.</p> <code>is_quality_data(sdo_image)</code> <p>Return True when the SDO image passes the QUALITY flag check.</p> <code>reduce_sdo_images(con_file, mag_file, dop_file, aia_file, mu_thresh=0.1, fit_cbs=False, **kwargs)</code> <p>Load, validate, and reduce a set of SDO images for a single epoch.</p> <p>This handles geometry setup, limb darkening, doppler/magnetogram corrections, and region classification.</p> <code>process_data_set_parallel(con_file, mag_file, dop_file, aia_file, mu_thresh, n_rings, datadir)</code> <p>Wrapper for multiprocessing that forwards to process_data_set.</p> <code>process_data_set(con_file, mag_file, dop_file, aia_file, mu_thresh, n_rings=10, suffix=None, datadir=None, **kwargs)</code> <p>Run the full processing pipeline and persist per-epoch outputs.</p>"},{"location":"public-api/#sdo_clv_pipelinesdo_vels","title":"sdo_clv_pipeline.sdo_vels","text":"<p>Velocity aggregation helpers for disk- and region-level summaries.</p> <code>compute_disk_results(mjd, flat_mu, flat_int, flat_v_corr, flat_v_rot, flat_ld, flat_iflat, flat_w_quiet, flat_w_active, flat_abs_mag, mu_thresh, k_hat_con)</code> <p>Compute disk-integrated velocity and intensity metrics.</p> <p>Parameters:</p> <ul> <li> <code>mjd</code>               (<code>float</code>)           \u2013            <p>Observation time in modified Julian date.</p> </li> <li> <code>flat_mu</code>               (<code>array - like</code>)           \u2013            <p>Flattened arrays of mu, intensity, corrected velocity, and rotation velocity.</p> </li> <li> <code>flat_int</code>               (<code>array - like</code>)           \u2013            <p>Flattened arrays of mu, intensity, corrected velocity, and rotation velocity.</p> </li> <li> <code>flat_v_corr</code>               (<code>array - like</code>)           \u2013            <p>Flattened arrays of mu, intensity, corrected velocity, and rotation velocity.</p> </li> <li> <code>flat_v_rot</code>               (<code>array - like</code>)           \u2013            <p>Flattened arrays of mu, intensity, corrected velocity, and rotation velocity.</p> </li> <li> <code>flat_ld</code>               (<code>array - like</code>)           \u2013            <p>Flattened limb-darkening model and flattened intensity.</p> </li> <li> <code>flat_iflat</code>               (<code>array - like</code>)           \u2013            <p>Flattened limb-darkening model and flattened intensity.</p> </li> <li> <code>flat_w_quiet</code>               (<code>array - like</code>)           \u2013            <p>Boolean weights for quiet and active regions.</p> </li> <li> <code>flat_w_active</code>               (<code>array - like</code>)           \u2013            <p>Boolean weights for quiet and active regions.</p> </li> <li> <code>flat_abs_mag</code>               (<code>array - like</code>)           \u2013            <p>Absolute magnetogram values.</p> </li> <li> <code>mu_thresh</code>               (<code>float</code>)           \u2013            <p>Minimum mu to include in the aggregation.</p> </li> <li> <code>k_hat_con</code>               (<code>float</code>)           \u2013            <p>Continuum scaling factor for the photometric term.</p> </li> </ul> <code>compute_region_only_results(mjd, flat_mu, flat_int, flat_v_corr, flat_v_rot, flat_ld, flat_iflat, flat_abs_mag, flat_w_quiet, flat_w_active, flat_reg, region_codes, mu_thresh, k_hat_con)</code> <p>Compute region-aggregated metrics across the full disk.</p> <code>compute_region_results(mjd, flat_mu, flat_int, flat_v_corr, flat_v_rot, flat_ld, flat_iflat, flat_abs_mag, flat_w_quiet, flat_w_active, flat_reg, region_codes, mu_thresh, n_rings, k_hat_con)</code> <p>Compute region-aggregated metrics in mu rings.</p>"},{"location":"public-api/#sdo_clv_pipelinesdo_plot","title":"sdo_clv_pipeline.sdo_plot","text":"<p>Plotting helpers for SDO images and region masks.</p> <code>plot_image(sdo_image, outdir=None, fname=None)</code> <p>Plot an SDOImage with WCS axes and type-specific styling.</p> <p>Parameters:</p> <ul> <li> <code>sdo_image</code>               (<code>SDOImage</code>)           \u2013            <p>Image to plot (magnetogram, dopplergram, continuum, or filtergram).</p> </li> <li> <code>outdir</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If provided, save to this directory instead of showing.</p> </li> <li> <code>fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Filename for the saved figure (auto-generated if None).</p> </li> </ul> <code>plot_mask(mask, outdir=None, fname=None)</code> <p>Plot a SunMask classification map with labeled region colors.</p> <code>label_moats_on_sun(mask, outdir=None, fname=None)</code> <p>Overlay moat region labels using precomputed moat data.</p>"},{"location":"public-api/#sdo_clv_pipelinesdo_download","title":"sdo_clv_pipeline.sdo_download","text":"<code>download_data(series='720', email=None, outdir=None, start=None, end=None, sample=None, overwrite=False, progress=False)</code>"},{"location":"public-api/#sdo_clv_pipelinelegendre","title":"sdo_clv_pipeline.legendre","text":"<p>Legendre basis helpers used for dopplergram bulk-velocity fits.</p> <code>gen_leg_vec(lmax, theta)</code> <p>Generate normalized Legendre basis and derivative vs latitude.</p> <p>This is used by dopplergram bulk-velocity modeling to build design matrices.</p> <p>Parameters:</p> <ul> <li> <code>lmax</code>               (<code>int</code>)           \u2013            <p>Maximum degree of the Legendre series.</p> </li> <li> <code>theta</code>               (<code>Quantity</code>)           \u2013            <p>Colatitude in degrees.</p> </li> </ul> <code>gen_leg_x_vec(lmax, x)</code> <p>Generate normalized Legendre basis and derivative vs x.</p> <p>This is used by dopplergram bulk-velocity modeling to build design matrices.</p> <p>Parameters:</p> <ul> <li> <code>lmax</code>               (<code>int</code>)           \u2013            <p>Maximum degree of the Legendre series.</p> </li> <li> <code>x</code>               (<code>Quantity</code>)           \u2013            <p>Coordinate in degrees (converted to radians internally).</p> </li> </ul>"},{"location":"public-api/#sdo_clv_pipelinereproject","title":"sdo_clv_pipeline.reproject","text":"<p>Lightweight WCS-based reprojection helpers.</p> <code>compute_pixel_mapping(src_wcs, dst_wcs, shape)</code> <p>Compute source pixel coordinates for each destination pixel.</p> <p>Parameters:</p> <ul> <li> <code>src_wcs</code>               (<code>WCS</code>)           \u2013            <p>Source image WCS.</p> </li> <li> <code>dst_wcs</code>               (<code>WCS</code>)           \u2013            <p>Destination image WCS.</p> </li> <li> <code>shape</code>               (<code>tuple</code>)           \u2013            <p>Destination image shape as (H, W).</p> </li> </ul> <code>bilinear_reproject(src, src_x, src_y, dst)</code> <p>Bilinearly sample src into dst using precomputed pixel mappings.</p>"}]}